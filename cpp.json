{
	"ldq":{
		"prefix":"ldq",
		"body":[
			"#include<bits/stdc++.h>"
			"#include<windows.h>"
			"using namespace std;"
			"int main(){"
			"	while(1)"
			"	{"
			"		if(GetAsyncKeyState(VK_F2))//F2"
			"		{"
			"			while(1)"
			"			{"
			"				mouse_event(MOUSEEVENTF_LEFTDOWN|MOUSEEVENTF_LEFTUP,0,0,0,0);"
			"				Sleep(10);"
			"				if(GetAsyncKeyState(VK_F4))//F4"
			"				{"
			"					break;"
			"				}"
			"			}"
			"		}"
			"	}"
			"	return 0;"
			"}"
		]
	},
	"readint":{
		"prefix":"readint",
		"body":[
			"int readint()"
			"{"
			"	int x=0,f=1;"
			"	char c=getchar();"
			"	while(c<'0'||c>'9')"
			"	{"
			"		if(c=='-')"
			"		{"
			"			f=-1;"
			"		}"
			"		c=getchar();"
			"	}"
			"	while(c>='0'&&c<='9')"
			"	{"
			"		x=(x<<1)+(x<<3)+(c^48),c=getchar();"
			"	}"
			"	return x*f;"
			"}"
        ]
    },
	"readlonglong":{
		"prefix":"readlonglong",
		"body":[
			"long long readlonglong()"
			"{"
			"	long long x=0,f=1;"
			"	char c=getchar();"
			"	while(c<'0'||c>'9')"
			"	{"
			"		if(c=='-')"
			"		{"
			"			f=-1;"
			"		}"
			"		c=getchar();"
			"	}"
			"	while(c>='0'&&c<='9')"
			"	{"
			"		x=(x<<1)+(x<<3)+(c^48),c=getchar();"
			"	}"
			"	return x*f;"
			"}"
        ]
    },
	"floyd":{
		"prefix":"floyd",
		"body":[
			"int n,dis[1000001][1000001];"
			"for(int i=1;i<=n;i++)"
			"{"
			"	for(int j=1;j<=n;j++)"
			"	{"
			"		cin>>dis[i][j];"
			"	}"
			"}"
			"for(int k=1;k<=n;k++)"
			"{"
			"	for(int i=1;i<=n;i++)"
			"	{"
			"		for(int j=1;j<=n;j++)"
			"		{"
			"			dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);"
			"		}"
			"	}"
			"}"
		]
	},
	"qian":{
		"prefix":"qian",
		"body":[
			"void qian(int u)"
			"{"
			"	if(u==-1)"
			"	{"
			"		return;"
			"	}"
			"	cout<<u;"
			"	qian(tree[u].l);"
			"	qian(tree[u].r);"
			"}"
		]
	},
	"zhong":{
		"prefix":"zhong",
		"body":[
			"void zhong(int u)"
			"{"
			"	if(u==-1)"
			"	{"
			"		return;"
			"	}"
			"	zhong(tree[u].l);"
			"	cout<<u;"
			"	zhong(tree[u].r);"
			"}"
		]
	},
	"hou":{
		"prefix":"hou",
		"body":[
			"void hou(int u)"
			"{"
			"	if(u==0)"
			"	{"
			"		return;"
			"	}"
			"	hou(tree[u].l);"
			"	hou(tree[u].r);"
			"	cout<<u;"
			"}"
		]
	},
	"quick_pow":{
		"prefix":"quick_pow",
		"body":[
			"int quick_pow(int a,int b,int mod)"
			"{"
			"	int res=1;"
			"	while(b)"
			"	{"
			"		if(b&1)"
			"		{"
			"			res=(res*a)%mod;"
			"		}"
			"		a=(a*a)%mod;"
			"		b>>=1;"
			"	}"
			"	return res;"
			"}"
		]
	},
	"bcj":{
		"prefix":"bcj",
		"body":[
			"int n,f[1000001];"
			"int find(int x)"
			"{"
			"	if(f[x]==x)"
			"	{"
			"		return x;"
			"	}"
			"	return f[x]=find(f[x]);"
			"}"
			"void merge(int a,int b)"
			"{"
			"	f[find(a)]=find(b);"
			"}"
			"bool judge(int a,int b)"
			"{"
			"	return find(a)==find(b);"
			"}"
			"for(int i=1;i<=n;i++)"
			"	{"
			"		f[i]=i;"
			"	}"
		]
	},
	"szsz":{
		"prefix":"szsz",
		"body":[
			"int n,t,ca[1000001],cb[1000001];"
			"int lowbit(int X)"
			"{"
			"	return X&(-X);"
			"}"
			"void update(int idx,int x)"
			"{"
			"	for(int i=idx;i<=n;i+=lowbit(i))"
			"	{"
			"		ca[i]+=x,cb[i]+=x*idx;"
			"	}"
			"}"
			"int sum(int v)"
			"{"
			"	t=0;"
			"	for(int i=v;i>0;i-=lowbit(i))"
			"	{"
			"		t+=(v+1)*ca[i]-cb[i];"
			"	}"
			"	return t;"
			"}"
			"/*"
			"update(l,x);"
			"update(r+1,-x);"
			"sum(r)-sum(l-1);"
			"*/"
			"for(int i=1;i<=n;i++)"
			"	{"
			"		update(i,a[i]-a[i-1]);"
			"	}"
		]
	},
	"lsqxx":{
		"prefix":"lsqxx",
		"body":[
			"int pos=0,head[1000001];"
			"struct edge"
			"{"
			"	int u,v,nxt;"
			"}e[2000001];"
			"void addedge(int u,int v)"
			"{"
			"	pos++,e[pos]={u,v,head[u]};"
			"	head[u]=pos;"
			"}"
			"for(int i=head[u];i;e[i].nxt)"
			"	{"
			"		"
			"	}"
		]
	},
	"xds":{
		"prefix":"xds",
		"body":[
			"#define ls(p) (p*2)"
			"#define rs(p) (p*2+1)"
			"int n,a[1000001];"
			"struct AB"
			"{"
			"	int l,r,v,tag;"
			"}tree[4000001];"
			"void build(int p,int l,int r)"
			"{"
			"	tree[p]={l,r,0,0};"
			"	if(l==r)"
			"	{"
			"		tree[p].v=a[l];"
			"		return;"
			"	}"
			"	int mid=(l+r)/2;"
			"	build(ls(p),l,mid),build(rs(p),mid+1,r);"
			"	tree[p].v=tree[ls(p)].v+tree[rs(p)].v;"
			"}"
			"void pushdown(int p)"
			"{"
			"	if(tree[p].l!=tree[p].r&&tree[p].tag)"
			"	{"
			"		tree[ls(p)].tag+=tree[p].tag,tree[rs(p)].tag+=tree[p].tag;"
			"		tree[ls(p)].v+=tree[p].tag*(tree[ls(p)].r-tree[ls(p)].l+1);"
			"		tree[rs(p)].v+=tree[p].tag*(tree[rs(p)].r-tree[rs(p)].l+1);"
			"		tree[p].tag=0;"
			"	}"
			"}"
			"int query(int p,int l,int r)"
			"{"
			"	if(l<=tree[p].l&&tree[p].r<=r)"
			"	{"
			"		return tree[p].v;"
			"	}"
			"	pushdown(p);"
			"	int res=0,mid=(tree[p].l+tree[p].r)/2;"
			"	if(l<=mid)"
			"	{"
			"		res=query(ls(p),l,r);"
			"	}"
			"	if(r>mid)"
			"	{"
			"		res+=query(rs(p),l,r);"
			"	}"
			"	return res;"
			"}"
			"void update(int p,int l,int r,int v)"
			"{"
			"	if(l<=tree[p].l&&tree[p].r<=r)"
			"	{"
			"		tree[p].tag+=v;"
			"		tree[p].v+=v*(tree[p].r-tree[p].l+1);"
			"		return;"
			"	}"
			"	pushdown(p);"
			"	int mid=(tree[p].l+tree[p].r)/2;"
			"	if(l<=mid)"
			"	{"
			"		update(ls(p),l,r,v);"
			"	}"
			"	if(r>mid)"
			"	{"
			"		update(rs(p),l,r,v);"
			"	}"
			"	tree[p].v=tree[ls(p)].v+tree[rs(p)].v;"
			"}"
			"/*"
			"update(1,l,r,x);"
			"query(1,l,r);"
			"*/"
			"build(1,1,n);"
		]
	},
	"quick_sort":{
		"prefix":"quick_sort",
		"body":[
			"int a[1000001];"
			"void quick_sort(int l,int r)"
			"{"
			"	if(l>=r)"
			"	{"
			"		return;"
			"	}"
			"	int mid=a[l+r>>1],left=l,right=r;"
			"	while(left<=right)"
			"	{"
			"		while(a[left]<mid)"
			"		{"
			"			left++;"
			"		}"
			"		while(a[right]>mid)"
			"		{"
			"			right--;"
			"		}"
			"		if(left<=right)"
			"		{"
			"			swap(a[left++],a[right--]);"
			"		}"
			"	}"
			"	quick_sort(l,right),quick_sort(left,r);"
			"}"
		]
	},
	"kruskal":{
		"prefix":"kruskal",
		"body":[
			"int n,m,ans=0,f[1000001];"
			"int find(int x)"
			"{"
			"	if(f[x]==x)"
			"	{"
			"		return x;"
			"	}"
			"	return f[x]=find(f[x]);"
			"}"
			"void merge(int a,int b)"
			"{"
			"	f[find(a)]=find(b);"
			"}"
			"bool judge(int a,int b)"
			"{"
			"	return find(a)==find(b);"
			"}"
			"for(int i=1;i<=n;i++)"
			"	{"
			"		f[i]=i;"
			"	}"
			"	for(int i=1;i<=m;i++)"
			"	{"
			"		cin>>a[i].u>>a[i].v>>a[i].w;"
			"	}"
			"	sort(a+1,a+m+1);"
			"	for(int i=1;i<=m;i++)"
			"	{"
			"		if(!judge(a[i].u,a[i].v))"
			"		{"
			"			ans+=a[i].w;"
			"			merge(a[i].u,a[i].v);"
			"		}"
			"	}"
			"	cout<<ans;"
		]
	},
	"szj":{
		"prefix":"szj",
		"body":[
			"int n,u,v,dep[1000001],maxd;"
			"vector<int>tree[1000001];"
			"void dfs(int u,int fa)"
			"{"
			"	for(int i=0;i<tree[u].size();i++)"
			"	{"
			"		if(tree[u][i]!=fa)"
			"		{"
			"			dep[tree[u][i]]=dep[u]+1;"
			"			if(dep[tree[u][i]]>dep[maxd])"
			"			{"
			"				maxd=tree[u][i];"
			"			}"
			"			dfs(tree[u][i],u);"
			"		}"
			"	}"
			"}"
			"cin>>n;"
			"	for(int i=1;i<n;i++)"
			"	{"
			"		cin>>u>>v;"
			"		tree[u].push_back(v);"
			"		tree[v].push_back(u);"
			"	}"
			"	dfs(1,0);"
			"	dep[maxd]=0;"
			"	dfs(maxd,0);"
			"	cout<<dep[maxd];"
		]
	},
	"ejzmj":{
		"prefix":"ejzmj",
		"body":[
			"int n;"
			"for(int i=0;i<1<<n;i++)"
			"{"
			"	for(int j=0;j<n;j++)"
			"	{"
			"		if(i>>j&1)"
			"		{"
			"			"
			"		}"
			"	}"
			"}"
		]
	},
}
